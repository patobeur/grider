<!DOCTYPE html>
<html lang="fr">

	<head>
		<title>three.js physics</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<style>
			body {
				overflow: hidden;
				margin: 0px;
			}

			#menuPanel {
				position: absolute;
				background-color: rgba(255, 255, 255, 0.25);
				top: 0px;
				left: 0px;
				width: 100%;
				height: 100%;
			}

			#startButton {
				height: 50px;
				width: 200px;
				/* margin: -25px -100px; */
				position: relative;
				/* top: 50%;
				left: 50%; */
				font-size: 32px;
				background-color: rgba(255, 255, 255, 1);
				text-align: center;
			}
		</style>
	</head>

	<body>
		<script src="/node_modules/three/examples/jsm/libs/ammo.wasm.js"></script>
		<script type="importmap">
		{
          "imports": {
            "three": "/node_modules/three/build/three.module.js",
            "three/addons/": "/node_modules/three/examples/jsm/"
          }
        }
      	</script>
		<script type="module">
			"use strict";
			import * as THREE from "three";
			import { _GLTFLoader, _TextureLoader, _scene } from '/assets/Loaders.js'
			// 
			import { clone } from 'three/addons/utils/SkeletonUtils.js';
			let PlayerStuff = {
				playerModel: undefined,
				playerTurret: undefined,
				pointerLocked: true,
				// euler: new THREE.Euler(),
				// quaternion: new THREE.Quaternion(),
				moveForward: false,
				moveBackward: false,
				turnLeft: false,
				turnRight: false,
				keyMap: {
					KeyW: false,
					KeyS: false,
					KeyA: false,
					KeyD: false,
				},
				checkMoves: function () {
					if (this.turnLeft) {
						this.playerModel.rotation.y += 0.05;
					} else if (this.turnRight) {
						this.playerModel.rotation.y -= 0.05;
					}
					if (this.moveBackward) {
						this.playerModel.translateZ(-0.1);
					} else if (this.moveForward) {
						this.playerModel.translateZ(0.1);
					}
				},

				onDocumentKey: function (e) {
					// console.log(ecode)
					if (e.type === "keydown" || e.type === "keyup") {
						PlayerStuff.keyMap[e.code] = e.type === "keydown";
					}
					if (PlayerStuff.pointerLocked) {
						PlayerStuff.moveForward = PlayerStuff.keyMap["KeyW"];
						PlayerStuff.moveBackward = PlayerStuff.keyMap["KeyS"];
						PlayerStuff.turnLeft = PlayerStuff.keyMap["KeyA"];
						PlayerStuff.turnRight = PlayerStuff.keyMap["KeyD"];
						// console.log(PlayerStuff.keyMap)
					}
				},
				pointerManager: function () {
					document.addEventListener("pointerlockchange", () => {
						if (document.pointerLockElement === _scene.renderer.domElement) {
							PlayerStuff.pointerLocked = true;

							PlayerStuff.startButton.style.display = "none";
							PlayerStuff.menuPanel.style.display = "none";

							document.addEventListener("keydown", PlayerStuff.onDocumentKey, false);
							document.addEventListener("keyup", PlayerStuff.onDocumentKey, false);

							_scene.renderer.domElement.addEventListener("mousemove", _OrbitControls.onDocumentMouseMove, false);
							_scene.renderer.domElement.addEventListener("wheel", _OrbitControls.onDocumentMouseWheel, false);
						} else {
							PlayerStuff.pointerLocked = false;

							PlayerStuff.menuPanel.style.display = "block";

							document.removeEventListener("keydown", PlayerStuff.onDocumentKey, false);
							document.removeEventListener("keyup", PlayerStuff.onDocumentKey, false);

							_scene.renderer.domElement.removeEventListener(
								"mousemove",
								_OrbitControls.onDocumentMouseMove,
								false
							);
							_scene.renderer.domElement.removeEventListener(
								"wheel",
								_OrbitControls.onDocumentMouseWheel,
								false
							);

							setTimeout(() => {
								PlayerStuff.startButton.style.display = "block";
							}, 1000);
						}
					});
				},
				panelManager: function () {
					this.menuPanel = document.createElement('div')
					this.startButton = document.createElement('div')
					this.menuPanel.id = 'menuPanel'
					this.startButton.id = 'startButton'
					this.startButton.textContent = 'startButton'
					this.menuPanel.appendChild(this.startButton)
					document.body.appendChild(this.menuPanel)
					this.startButton.addEventListener(
						"click",
						() => {
							_scene.renderer.domElement.requestPointerLock();
						},
						false
					);
				},
				init: function () {
					// _GLTFLoader.addModelsToScene(scene)
					this.playerModel = clone(_GLTFLoader.models.tank1)

					this.playerTurret = this.playerModel.children[0].children[3]

					this.playerModel.position.set(0, 0, 0)

					// this.playerModel.name = 'playerOne'
					// this.playerModel.children[0].material.color.r = 1
					// this.playerModel.children[0].material.color.g = 0
					// this.playerModel.children[0].material.color.b = 0
					// this.playerTurret.material.color.r = 1
					// this.playerTurret.material.color.g = 0
					// this.playerTurret.material.color.b = 1

					_scene.scene.add(this.playerModel)

					this.panelManager()
					this.pointerManager()
					// orbitControls.set_cameraPivot()

				}

			};
			let _OrbitControls = {
				active: false,
				// ------------------------
				// CAMERA PIVOT TURRET
				// ------------------------
				cubepitch: new THREE.Mesh(new THREE.BoxGeometry(.15, .05, .25), new THREE.MeshPhongMaterial({ color: 0xFF0000 })),
				cubeyaw: new THREE.Mesh(new THREE.BoxGeometry(.05, .15, .25), new THREE.MeshPhongMaterial({ color: 0x00FF00 })),
				cubepivot: new THREE.Mesh(new THREE.BoxGeometry(.05, .15, .25), new THREE.MeshPhongMaterial({ color: 0x0000ff })),

				yaw: new THREE.Object3D(), // object dont on utilise l'axe Y
				// pivot: new THREE.Object3D(),
				// pitch: new THREE.Object3D(),
				// ------------------------
				// INIT
				// ------------------------
				init: function (camera, renderer, PlayerStuff) {
					this.groupe = new THREE.Group()
					this.groupe.position.y = 0
					this.groupe.position.x = 0
					this.groupe.position.z = -.75
					this.cubeyaw.position.x = .25
					this.cubepitch.position.x = -.25
					this.groupe.add(this.cubeyaw, this.cubepitch, this.cubepivot)
					PlayerStuff.playerTurret.add(this.groupe)

					PlayerStuff.playerTurret.add(camera)
					camera.position.z = -8;
					camera.rotation.z = -Math.PI
					camera.position.y = 2;
					camera.lookAt(new THREE.Vector3(0, 0, 5))
					this.active = true
				},
				update: function () {
					if (this.active === true) {
						// to do
						_OrbitControls.cubepivot.rotation.y = PlayerStuff.playerModel.rotation.y + 0
					}
				},
				//-----------------
				onDocumentMouseMove: function (e) {
					_OrbitControls.cubeyaw.rotation.y -= e.movementX * 0.002;
					_OrbitControls.cubepitch.rotation.x += e.movementY * 0.002;
					_scene.camera.rotation.x += e.movementY * 0.002;
					PlayerStuff.playerTurret.rotation.y = _OrbitControls.cubeyaw.rotation.y;
					return false;
				},
				onDocumentMouseWheel: function (e) {
					const hauteur = _scene.camera.position.y + e.deltaY * 0.005;
					console.log(hauteur)
					if (hauteur >= 0 && hauteur <= 5) {
						_scene.camera.position.y = hauteur;
					}
					return false;
				}
			}
			let initWorld = (Ammo) => {
				let root = '';
				_scene.init()
				let scene = _scene.scene
				let camera = _scene.camera
				let renderer = _scene.renderer
				let cubepivot = _scene.cubepivot
				// ------------------------
				// ANIMATION
				// ------------------------
				const animate = function () {
					requestAnimationFrame(animate);
					_scene.SUN.move()
					// if (_GLTFLoader.demoActive === true) _GLTFLoader.rotTankBase()

					PlayerStuff.checkMoves()

					if (typeof _OrbitControls === 'object') _OrbitControls.update();

					renderer.render(scene, camera);
				};
				// ------------------------
				// PLAYER
				// ------------------------

				// ------------------------
				// STEPS
				// ------------------------
				let STEP4 = () => {
					// ------------------------
					// FLOOR
					// ------------------------
					const floorGeometry = new THREE.BoxGeometry(192 / 3, 1, 197 / 3);
					const floorMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF, map: _TextureLoader.textures['floor2'].map });
					const floor = new THREE.Mesh(floorGeometry, floorMaterial);
					floor.castShadow = true;
					floor.receiveShadow = true
					// floor.rotation.x = -Math.PI / 2;
					floor.position.y = -1;
					scene.add(floor);
					// ------------------------
					// ADD MODELS
					// ------------------------
					_GLTFLoader.addModelsToScene(scene)
					PlayerStuff.init()
					_OrbitControls.init(camera, renderer, PlayerStuff)
					renderer.render(scene, camera);

					animate();

				}
				let STEP3 = () => {
					STEP4()
				}
				let STEP2 = () => {
					_TextureLoader.init(root, STEP3)
				}
				let STEP = () => {
					_GLTFLoader.init(root, STEP2)
				}
				// ------------------------
				// Handle window resizing
				// ------------------------
				window.addEventListener('resize', () => {
					renderer.setSize(window.innerWidth, window.innerHeight);
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
				});

				STEP()
			}
			Ammo().then(initWorld);
		</script>
	</body>

</html>
