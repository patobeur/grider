<!DOCTYPE html>
<html lang="fr">

	<head>
		<title>three.js physics</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<style>
			body {
				overflow: hidden;
				margin: 0px;
			}

			#menuPanel {
				position: absolute;
				background-color: rgba(255, 255, 255, 0.25);
				top: 0px;
				left: 0px;
				width: 100%;
				height: 100%;
			}

			#startButton {
				height: 50px;
				width: 200px;
				margin: -25px -100px;
				position: relative;
				top: 50%;
				left: 50%;
				font-size: 32px;
				background-color: rgba(255, 255, 255, 1);
				text-align: center;
			}
		</style>
	</head>

	<body>
		<script src="/node_modules/three/examples/jsm/libs/ammo.wasm.js"></script>
		<script type="importmap">
		{
          "imports": {
            "three": "/node_modules/three/build/three.module.js",
            "three/addons/": "/node_modules/three/examples/jsm/"
          }
        }
      	</script>
		<script type="module">
			"use strict";
			import * as THREE from "three";
			import { _GLTFLoader, _TextureLoader, _scene } from '/assets/Loaders.js'
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
			import { clone } from 'three/addons/utils/SkeletonUtils.js';
			let initWorld = (Ammo) => {
				let root = '';
				_scene.init()
				let scene = _scene.scene
				let camera = _scene.camera
				let renderer = _scene.renderer
				// ------------------------
				// ANIMATION
				// ------------------------
				const animate = function () {
					requestAnimationFrame(animate);
					_scene.SUN.move()
					if (_GLTFLoader.demoActive === true) _GLTFLoader.rotTankBase()

					PlayerStuff.checkMoves()

					if (typeof orbitControls === 'object') orbitControls.update();

					renderer.render(scene, camera);
				};
				let orbitControls = {
					active: false,
					controls: undefined,
					init: function (camera, renderer) {
						this.controls = new OrbitControls(camera, renderer.domElement)
						this.controls.enablePan = false;
						this.controls.maxPolarAngle = Math.PI / 2;
						this.controls.minDistance = 2;
						this.controls.maxDistance = 50;
						// plus de vitesse ou de smooth
						// this.controls.enableDamping = true;
						// this.controls.dampingFactor = 0.09;
						// this.controls.autoRotate = true;
						// this.controls.enableRotate = false;
						this.active = true;
						// this.controls.update();
					},
					set_cameraPivot: function () {


						PlayerStuff.pitch.add(camera);  // Et la caméra est ajoutée à `pitch` qui est déjà ajouté à `yaw`
						PlayerStuff.pivot.add(PlayerStuff.yaw);// La caméra est ajoutée à `yaw` qui est déjà ajouté à `pivot`
						PlayerStuff.pivot.position.set(0, 1, -5); // Ajustez la position du pivot pour être devant le canon du tank
						PlayerStuff.yaw.add(PlayerStuff.pitch);
						PlayerStuff.playerModel.add(PlayerStuff.pivot);
					},
					update: function () {
						if (orbitControls.active === true) this.controls.update();
					}

				}
				// ------------------------
				// PLAYER
				// ------------------------
				let PlayerStuff = {
					playerModel: undefined,
					playerTurret: undefined,
					pointerLocked: true,
					engineSpeed: { current: 0, min: -5, max: 5 },
					euler: new THREE.Euler(),
					quaternion: new THREE.Quaternion(),
					moveForward: false,
					moveBackward: false,
					turnLeft: false,
					turnRight: false,
					keyMap: {
						KeyW: false,
						KeyS: false,
						KeyA: false,
						KeyD: false,
					},
					keys: {

					},
					// ------------------------
					// CAMERA PIVOT TURRET
					// ------------------------
					directionVectorTuret: new THREE.Vector3(),
					pivot: new THREE.Object3D(),
					yaw: new THREE.Object3D(),
					pitch: new THREE.Object3D(),
					//-----------------
					//-----------------
					onDocumentMouseMove: function (e) {
						PlayerStuff.yaw.rotation.y -= e.movementX * 0.002;
						const v = PlayerStuff.pitch.rotation.x - e.movementY * 0.002;
						if (v > -1 && v < 0.1) {
							PlayerStuff.pitch.rotation.x = v;
						}
						PlayerStuff.directionVectorTuret = PlayerStuff.yaw.rotation.y + Math.PI;

						PlayerStuff.playerModel.children[0].children[3].rotation.y = PlayerStuff.directionVectorTuret;
						// camera.lookAt(PlayerStuff.playerModel.position); // Assurez-vous que la caméra regarde toujours le modèle du joueur
						return false;
					},
					onDocumentMouseWheel: function (e) {
						console.log(camera)
						// const v = camera.position.z + e.deltaY * 0.005;
						// if (v >= 2 && v <= 10) {
						// 	camera.position.z = v;
						// }
						// return false;
					},
					checkMoves: function () {
						if (PlayerStuff.turnLeft) {
							PlayerStuff.playerModel.rotation.y += 0.05;
						} else if (PlayerStuff.turnRight) {
							PlayerStuff.playerModel.rotation.y -= 0.05;
						}
						if (PlayerStuff.moveBackward) {
							PlayerStuff.playerModel.translateZ(-0.1); // 
						} else if (PlayerStuff.moveForward) {
							PlayerStuff.playerModel.translateZ(0.1); // 
						}
						this.pivot.position.copy(this.playerModel.position);  // Assure que le pivot suit la position du tank
					},

					onDocumentKey: function (e) {
						console.log(e.code)
						if (e.type === "keydown" || e.type === "keyup") {
							PlayerStuff.keyMap[e.code] = e.type === "keydown";
						}
						if (PlayerStuff.pointerLocked) {
							PlayerStuff.moveForward = PlayerStuff.keyMap["KeyW"];
							PlayerStuff.moveBackward = PlayerStuff.keyMap["KeyS"];
							PlayerStuff.turnLeft = PlayerStuff.keyMap["KeyA"];
							PlayerStuff.turnRight = PlayerStuff.keyMap["KeyD"];
							console.log(PlayerStuff.keyMap)
						}
					},
					pointerManager: function () {
						document.addEventListener("pointerlockchange", () => {
							if (document.pointerLockElement === renderer.domElement) {
								PlayerStuff.pointerLocked = true;

								PlayerStuff.startButton.style.display = "none";
								PlayerStuff.menuPanel.style.display = "none";

								document.addEventListener("keydown", PlayerStuff.onDocumentKey, false);
								document.addEventListener("keyup", PlayerStuff.onDocumentKey, false);

								renderer.domElement.addEventListener("mousemove", PlayerStuff.onDocumentMouseMove, false);
								renderer.domElement.addEventListener("wheel", PlayerStuff.onDocumentMouseWheel, false);
							} else {
								PlayerStuff.pointerLocked = false;

								PlayerStuff.menuPanel.style.display = "block";

								document.removeEventListener("keydown", PlayerStuff.onDocumentKey, false);
								document.removeEventListener("keyup", PlayerStuff.onDocumentKey, false);

								renderer.domElement.removeEventListener(
									"mousemove",
									PlayerStuff.onDocumentMouseMove,
									false
								);
								renderer.domElement.removeEventListener(
									"wheel",
									PlayerStuff.onDocumentMouseWheel,
									false
								);

								setTimeout(() => {
									PlayerStuff.startButton.style.display = "block";
								}, 1000);
							}
						});
					},
					panelManager: function () {
						this.menuPanel = document.createElement('div')
						this.startButton = document.createElement('div')
						this.menuPanel.id = 'menuPanel'
						this.startButton.id = 'startButton'
						this.startButton.textContent = 'startButton'
						this.menuPanel.appendChild(this.startButton)
						document.body.appendChild(this.menuPanel)
						this.startButton.addEventListener(
							"click",
							() => {
								renderer.domElement.requestPointerLock();
							},
							false
						);
					},
					init: function () {
						// _GLTFLoader.addModelsToScene(scene)
						this.playerModel = clone(_GLTFLoader.models.tank1)

						this.playerTurret = this.playerModel.children[0].children[3]

						this.playerModel.position.set(0, 0, 0)

						// this.playerModel.name = 'playerOne'
						this.playerModel.children[0].material.color.r = 1
						this.playerModel.children[0].material.color.g = 0
						this.playerModel.children[0].material.color.b = 0
						this.playerModel.children[0].children[3].material.color.r = 1
						this.playerModel.children[0].children[3].material.color.g = 0
						this.playerModel.children[0].children[3].material.color.b = 1

						scene.add(this.playerModel)

						orbitControls.set_cameraPivot()
						this.panelManager()
						this.pointerManager()

					}

				};

				// ------------------------
				// STEPS
				// ------------------------
				let STEP4 = () => {
					// ------------------------
					// FLOOR
					// ------------------------
					const floorGeometry = new THREE.BoxGeometry(192 / 3, 1, 197 / 3);
					const floorMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF, map: _TextureLoader.textures['floor2'].map });
					const floor = new THREE.Mesh(floorGeometry, floorMaterial);
					floor.castShadow = true;
					floor.receiveShadow = true
					// floor.rotation.x = -Math.PI / 2;
					floor.position.y = -1;
					scene.add(floor);
					// ------------------------
					// ADD MODELS
					// ------------------------
					_GLTFLoader.addModelsToScene(scene)
					PlayerStuff.init()

					orbitControls.init(camera, renderer)

					renderer.render(scene, camera);

					animate();

				}
				let STEP3 = () => {
					STEP4()
				}
				let STEP2 = () => {
					_TextureLoader.init(root, STEP3)
				}
				let STEP = () => {
					_GLTFLoader.init(root, STEP2)
				}
				// ------------------------
				// Handle window resizing
				// ------------------------
				window.addEventListener('resize', () => {
					renderer.setSize(window.innerWidth, window.innerHeight);
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
				});

				STEP()
			}
			Ammo().then(initWorld);
		</script>
	</body>

</html>
