<!DOCTYPE html>
<html lang="fr">

	<head>
		<title>three.js physics - ammo.js instancing</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	</head>

	<body>
		<style>
			body {
				overflow: hidden;
				margin: 0px;
			}

			#instructions {
				color: white;
				position: absolute;
				left: 50%;
				top: 10px;
				margin-left: -220px;
				font-family: monospace;
			}

			#menuPanel {
				position: absolute;
				background-color: rgba(255, 255, 255, 0.25);
				top: 0px;
				left: 0px;
				width: 100%;
				height: 100%;
			}

			#startButton {
				height: 50px;
				width: 200px;
				margin: -25px -100px;
				position: relative;
				top: 50%;
				left: 50%;
				font-size: 32px;
			}
		</style>
		<div id="instructions">
			W A S D to move capsule<br />Mousemove to rotate<br />Mousewheel to dolly in/out
		</div>
		<div id="menuPanel">
			<button id="startButton">Click to Start</button>
		</div>
		<script src="/node_modules/three/examples/jsm/libs/ammo.wasm.js"></script>
		<script type="importmap">
		{
          "imports": {
            "three": "/node_modules/three/build/three.module.js",
            "three/addons/": "/node_modules/three/examples/jsm/"
          }
        }
      	</script>
		<script type="module">
			import * as THREE from "three";
			import Stats from 'three/addons/libs/stats.module.js';
			let initWorld = (Ammo) => {
				let _physics = {
					// Ammo.js
					gravity: new THREE.Vector3(0, -9.810, 0),
					inertia: new THREE.Vector3(0, 0, 0),
					tmpTransformation: undefined,
					physicsWorld: undefined,
					rigidBody_List: new Array(),
					_initPhysicsWorld: function () {
						this.tmpTransformation = new Ammo.btTransform();
						var collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
						var dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
						var overlappingPairCache = new Ammo.btDbvtBroadphase();
						var solver = new Ammo.btSequentialImpulseConstraintSolver();
						this.physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
						this.physicsWorld.setGravity(new Ammo.btVector3(this.gravity.x, this.gravity.y, this.gravity.z));
					},
					_transform: function (position, quaternion) {
						let transform = new Ammo.btTransform();
						transform.setIdentity();
						transform.setOrigin(new Ammo.btVector3(position.x, position.y, position.z));
						transform.setRotation(new Ammo.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w));
						return transform
					},
					_quaternion: function (rotation_q) {

						let quaternion = undefined;
						if (rotation_q == null) {
							quaternion = { x: 0, y: 0, z: 0, w: 1 };
						}
						else {
							quaternion = rotation_q;
						}
						return quaternion
					},
					_updatePhysicsWorld: function (deltaTime) {
						this.physicsWorld.stepSimulation(deltaTime, 10);
						for (let i = 0; i < this.rigidBody_List.length; i++) {
							let Graphics_Obj = this.rigidBody_List[i];
							if (Graphics_Obj.name === 'toto') console.log('name:', Graphics_Obj.name)
							let Physics_Obj = Graphics_Obj.userData.physicsBody;

							let motionState = Physics_Obj.getMotionState();

							if (motionState) {

								motionState.getWorldTransform(this.tmpTransformation);
								let new_pos = this.tmpTransformation.getOrigin();
								let new_qua = this.tmpTransformation.getRotation();
								Graphics_Obj.position.set(new_pos.x(), new_pos.y(), new_pos.z());
								Graphics_Obj.quaternion.set(new_qua.x(), new_qua.y(), new_qua.z(), new_qua.w());
							}
						}
					},
					get_geometry: function (shape) {
						let geo = undefined
						switch (shape) {
							case 'Box':
								geo = new THREE.BoxGeometry(1, 1, 1)
								break;
							case 'Sphere':
								geo = new THREE.SphereGeometry(0.5, 12, 8)
								break;
							case 'Dodecahedron':
								geo = new THREE.DodecahedronGeometry(0.5)
								break;
							case 'Cylinder':
								geo = new THREE.CylinderGeometry(0.5, 0.5, 1, 1)
								break;
							default:
								geo = new THREE.BoxGeometry(1, 1, 1)
								break;
						}
						return geo
					},
					createMesh: function (scale, position, mass, color, rotation_q, categorie) {
						let catMesh = undefined
						let catShape = undefined
						let newMesh = undefined
						let quaternion = this._quaternion(rotation_q)
						// ------ Physics World - Ammo.js ------
						let transform = this._transform(position, quaternion)
						// ------ Graphics World - Three.JS ------
						const geometry = new THREE.BoxGeometry(scale.x, scale.y, scale.z)
						const material = new THREE.MeshPhongMaterial({ color: color })
						// mesh
						newMesh = new THREE.Mesh(geometry, material);
						newMesh.position.set(position.x, position.y, position.z);
						newMesh.rotation.set(new THREE.Vector3(Math.Pi / 5, Math.Pi / 5, Math.Pi / 5));
						newMesh.castShadow = true;
						newMesh.receiveShadow = true;
						// chapeau
						// const geometry2 = new THREE.BoxGeometry(.2, .2, .2)
						// const material2 = new THREE.MeshPhongMaterial({ color: 0x000000 })
						// let newMesh2 = new THREE.Mesh(geometry2, material2);
						// newMesh2.castShadow = true;
						// newMesh2.receiveShadow = true;
						// newMesh.add(newMesh2)
						// newMesh2.position.y = scale.y / 2;
						let structColShape = new Ammo.btBoxShape(new Ammo.btVector3(scale.x * 0.5, scale.y * 0.5, scale.z * 0.5));
						structColShape.setMargin(0.05);
						structColShape.calculateLocalInertia(mass, this.inertia);
						// --
						let defaultMotionState = new Ammo.btDefaultMotionState(transform);
						let RBody_Info = new Ammo.btRigidBodyConstructionInfo(mass, defaultMotionState, structColShape, this.inertia);
						let RBody = new Ammo.btRigidBody(RBody_Info);
						// RBody.setFriction(0.01);
						this.physicsWorld.addRigidBody(RBody);
						newMesh.userData.physicsBody = RBody;
						newMesh.userData.collided = false;
						this.rigidBody_List.push(newMesh);
						return newMesh
					},
				}
				let _scene = {
					scene: undefined,
					camera: undefined,
					renderer: undefined,
					player: undefined,
					init: function () {
						this.scene = new THREE.Scene();
						this.scene.add(new THREE.GridHelper());

						{
							const light = new THREE.DirectionalLight(0xFFFFFF, 3);
							light.position.set(20, 20, 20);
							light.shadow.mapSize.width = 1024; // default
							light.shadow.mapSize.height = 1024; // default
							light.shadow.camera.near = 2; // default
							light.shadow.camera.far = 50; // default
							light.name = 'sun'
							const d = 14;
							light.shadow.camera.left = -d;
							light.shadow.camera.right = d;
							light.shadow.camera.top = d;
							light.shadow.camera.bottom = -d;
							this.scene.add(light);

							const ambientLight = new THREE.AmbientLight(0xbbbbbb);
							this.scene.add(ambientLight);
						}
						// camera
						this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
						this.camera.position.set(0, 1, 5);
						// renderer
						this.renderer = new THREE.WebGLRenderer({ antialias: true });
						this.renderer.setPixelRatio(window.devicePixelRatio);
						this.renderer.setSize(window.innerWidth, window.innerHeight);
						this.renderer.shadowMap.enabled = true;
						this.renderer.shadowMap.enabled = true;
						document.body.appendChild(this.renderer.domElement);

					},
				}
				_physics._initPhysicsWorld()
				_scene.init()

				_scene.floor = _physics.createMesh(new THREE.Vector3(40, .5, 40), new THREE.Vector3(0, -.25, 0), 0, 0xffffff, null, 'Box');
				_scene.scene.add(_scene.floor)
				_scene.player = _physics.createMesh(new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 15, 0), 1, 0xffffff, null, 'Box');
				_scene.scene.add(_scene.floor, _scene.player)

				const geometry = new THREE.CapsuleGeometry();
				const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });

				// const capsule = new THREE.Mesh(geometry, material);
				// capsule.position.y = 1.5;
				// _scene.scene.add(capsule);

				const pivot = new THREE.Object3D();
				pivot.position.set(0, 1, 0);

				const yaw = new THREE.Object3D();
				const pitch = new THREE.Object3D();

				_scene.scene.add(pivot);
				pivot.add(yaw);
				yaw.add(pitch);
				pitch.add(_scene.camera);

				window.addEventListener("resize", onWindowResize, false);

				function onWindowResize() {
					_scene.camera.aspect = window.innerWidth / window.innerHeight;
					_scene.camera.updateProjectionMatrix();
					_scene.renderer.setSize(window.innerWidth, window.innerHeight);
					render();
				}

				function onDocumentMouseMove(e) {
					yaw.rotation.y -= e.movementX * 0.002;
					const v = pitch.rotation.x - e.movementY * 0.002;
					if (v > -1 && v < 0.1) {
						pitch.rotation.x = v;
					}
					return false;
				}

				function onDocumentMouseWheel(e) {
					const v = _scene.camera.position.z + e.deltaY * 0.005;
					if (v >= 2 && v <= 10) {
						_scene.camera.position.z = v;
					}
					return false;
				}

				let moveForward = false;
				let moveBackward = false;
				let moveLeft = false;
				let moveRight = false;
				const keyMap = {};
				const onDocumentKey = (e) => {
					keyMap[e.code] = e.type === "keydown";

					if (pointerLocked) {
						moveForward = keyMap["KeyW"];
						moveBackward = keyMap["KeyS"];
						moveLeft = keyMap["KeyA"];
						moveRight = keyMap["KeyD"];
					}
				};

				const menuPanel = document.getElementById("menuPanel");
				const startButton = document.getElementById("startButton");
				startButton.addEventListener(
					"click",
					() => {
						_scene.renderer.domElement.requestPointerLock();
					},
					false
				);

				let pointerLocked = false;
				document.addEventListener("pointerlockchange", () => {
					if (document.pointerLockElement === _scene.renderer.domElement) {
						pointerLocked = true;

						startButton.style.display = "none";
						menuPanel.style.display = "none";

						document.addEventListener("keydown", onDocumentKey, false);
						document.addEventListener("keyup", onDocumentKey, false);

						_scene.renderer.domElement.addEventListener("mousemove", onDocumentMouseMove, false);
						_scene.renderer.domElement.addEventListener("wheel", onDocumentMouseWheel, false);
					} else {
						pointerLocked = false;

						menuPanel.style.display = "block";

						document.removeEventListener("keydown", onDocumentKey, false);
						document.removeEventListener("keyup", onDocumentKey, false);

						_scene.renderer.domElement.removeEventListener(
							"mousemove",
							onDocumentMouseMove,
							false
						);
						_scene.renderer.domElement.removeEventListener(
							"wheel",
							onDocumentMouseWheel,
							false
						);

						setTimeout(() => {
							startButton.style.display = "block";
						}, 1000);
					}
				});

				const stats = new Stats();
				document.body.appendChild(stats.dom);

				const v = new THREE.Vector3();
				const inputVelocity = new THREE.Vector3();
				const euler = new THREE.Euler();
				const quaternion = new THREE.Quaternion();

				const clock = new THREE.Clock();
				let delta = 0;

				function animate() {
					requestAnimationFrame(animate);

					delta = clock.getDelta();

					_physics._updatePhysicsWorld(delta);

					inputVelocity.set(0, 0, 0);

					if (moveForward) {
						inputVelocity.z = -5 * delta;
					}
					if (moveBackward) {
						inputVelocity.z = 5 * delta;
					}

					if (moveLeft) {
						inputVelocity.x = 5 * delta;
					}
					if (moveRight) {
						inputVelocity.x = 5 * delta;
					}

					// apply camera rotation to inputVelocity
					euler.y = yaw.rotation.y;
					quaternion.setFromEuler(euler);
					inputVelocity.applyQuaternion(quaternion);

					//capsule.position.add(inputVelocity);


					// Mettre à jour la position de _scene.player à travers son corps rigide
					let playerPhysicsBody = _scene.player.userData.physicsBody;
					let ms = playerPhysicsBody.getMotionState();
					if (ms) {
						let transform = new Ammo.btTransform();
						ms.getWorldTransform(transform);
						let position = transform.getOrigin();
						position.setX(position.x() + inputVelocity.x);
						position.setY(position.y() + inputVelocity.y);
						position.setZ(position.z() + inputVelocity.z);


						transform.setOrigin(position);

						let rotation = new Ammo.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
						transform.setRotation(rotation);


						ms.setWorldTransform(transform);
						playerPhysicsBody.setMotionState(ms);
					}

					_scene.player.getWorldPosition(v);
					pivot.position.lerp(v, 0.1);

					render();

					stats.update();
				}

				function render() {
					_scene.renderer.render(_scene.scene, _scene.camera);
				}

				animate();
			}
			Ammo().then(initWorld);
		</script>
	</body>

</html>
